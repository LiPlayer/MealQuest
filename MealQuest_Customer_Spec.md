# 餐餐有戏 - 顾客端产品与工程规范 (Master-Aligned V2.0)

> 依据：`MealQuest_Spec.md`（唯一标准）
> 目标：把“扫码即达 -> 候餐互动 -> 智能支付 -> 资产沉淀”闭环落到小程序可执行工程。

---

## 1. 规范边界（与总规范强一致）

1. 本端是 **私域支付与资产运营入口**，不是点餐系统。
2. 顾客端必须围绕四类资产展开：`聚宝金库`、`寻味碎银`、`食福碎片`、`口福红包`。
3. 所有动态营销触达必须来自服务端 TCA/Story JSON，不允许端上“自作主张”发券。
4. 支付策略执行优先级必须遵循：`临期口福红包 > 余额账户（赠送金优先）> 碎银 > 外部支付`。

---

## 2. 顾客端信息架构

## 2.1 页面与层级

1. `startup`：冷启动与门店绑定。
2. `index`：品牌首页容器（品牌区 + 资产卡堆 + 活动区 + 收银坞）。
3. `account`：账户中心（钱包总览 + 支付流水 + 发票列表 + 账号注销）。

## 2.2 首页模块

1. 品牌区：门店名称、分店、营业状态，强调去平台化。
2. 资产卡堆：
   - `P02 聚宝金库`：本金/赠送金。
   - `P01 寻味碎银`：碎银总额与活跃指标。
   - `P04 食福碎片`：普通/稀有碎片库存。
   - `P03 口福红包`：可核销资产（含临期优先）。
3. 活动区：优先展示服务端返回的 `activities`（由 TCA 活动实时映射），无远程数据时回退本地兜底活动。
4. 底部收银坞：展示智能抵扣预览和最终应付金额。
5. 顶部账户入口：一键跳转到账户中心。

## 2.3 账户中心模块

1. 钱包总览：本金/赠送金/碎银实时状态。
2. 支付流水：按时间倒序展示顾客本人账务记录（只读）。
3. 发票列表：展示顾客本人可下载发票（手动/自动回传结果统一承接）。
4. 自助注销：二次确认后调用注销接口，并清理本地会话缓存。

---

## 3. 核心业务规则

## 3.1 资产模型

1. `wallet.principal`：可退本金。
2. `wallet.bonus`：赠送金，不可提现。
3. `wallet.silver`：寻味碎银。
4. `vouchers[]`：口福红包资产，最小字段：`id/name/value/status/expiresAt/minSpend`。
5. `fragments`：普通与稀有碎片计数。

## 3.2 智能收银算法

输入：`orderAmount + wallet + vouchers`。

执行顺序：
1. 选择可用且未过期的红包，按“临期优先，其次价值高”排序。
2. 扣减红包金额。
3. 扣减赠送金 `bonus`。
4. 扣减本金 `principal`。
5. 扣减碎银 `silver`。
6. 生成外部支付差额 `external`。

输出：
1. 抵扣明细。
2. 最终应付。
3. 扣减后的钱包快照。

## 3.3 启动与门店锁定

1. 若 URL 参数含 `id/scene`，强制绑定并进入首页。
2. 若本地有最近门店，直接回到该门店。
3. 否则进入扫码引导页。

---

## 4. 服务端协同契约

## 4.1 顾客端依赖 API（逻辑层）

1. `getHomeSnapshot(storeId, userId)`：获取首页资产快照。
2. `getCheckoutQuote(storeId, orderAmount, userId)`：获取收银预览。
3. `executeCheckout(storeId, orderAmount, userId)`：执行支付并返回新快照。
4. `getPaymentLedger(storeId, userId, limit)`：查询顾客本人支付流水。
5. `getInvoices(storeId, userId, limit)`：查询顾客本人发票列表。
6. `cancelAccount(storeId, userId)`：顾客自助注销账号。
7. 远程调用必须使用服务端下发的 `CUSTOMER` token，并受 `merchantId/userId` scope 约束。
8. `homeSnapshot.activities` 必须可承接服务端动态策略投放卡（而非端上写死模板）。

## 4.2 运行模式与切换

1. 默认模式：本地 Mock（保证离线演示与测试稳定）。
2. 远程模式：当 `TARO_APP_USE_REMOTE_API=true` 且 `TARO_APP_SERVER_BASE_URL` 存在时，优先走服务端 API。
3. 远程成功快照需本地缓存（按 `storeId+userId` 维度），用于弱网兜底。
4. 远程失败优先回退本地缓存快照，再回退 Mock，不阻断顾客支付流程。
5. 远程模式下自动向服务端申请 `CUSTOMER` token，无需手工登录。
6. 服务端 `state` 返回活动注入时，顾客端需零配置渲染并保持视觉兜底。

## 4.3 Story/TCA 注入约束

1. 活动卡可展示 TCA 事件注入内容。
2. 顾客端仅渲染，不做规则决策。

---

## 5. 工程实现约束

1. `Taro + React`，严格使用小程序抽象 API。
2. 卡片层叠动效保持可交互并支持点击聚焦。
3. 所有核心逻辑函数必须可单测（纯函数优先）。
4. Mock 服务必须具备“可变状态”，不能只有静态常量。

---

## 6. 测试规范

## 6.1 必测用例

1. `startup`：新客/老客/扫码三分支。
2. 智能收银算法：临期券优先与外部支付差额。
3. 卡片交互：展开/收起与焦点切换。
4. Mock 支付执行后：钱包下降、红包状态变更。
5. 远程模式成功时走 API，失败时自动回退（缓存快照 -> Mock）且清空失效 token。
6. 远程模式下首页活动区可渲染服务端动态策略卡。
7. 账户中心可加载“本人流水 + 本人发票”，并校验跨用户 scope 拒绝。
8. 账号注销采用“二次确认 -> 调服务端 -> 清理会话 -> 回到启动页”闭环。
9. E2E 需覆盖“startup -> index -> account”主路径可达性与注销二次确认交互。

## 6.2 覆盖要求

1. 资产与支付相关 domain 逻辑必须有单测。
2. 页面行为至少覆盖启动页、首页、账户中心核心流程。

---

## 7. 需求追踪矩阵（总规范 -> 顾客端）

| ID | 总规范条款 | 顾客端要求 | 验收方式 |
| :-- | :-- | :-- | :-- |
| C-01 | 扫码即达私域门店 | 启动页只做门店绑定，不提供门店市场页 | 启动流程测试 |
| C-02 | 四类资产经济系统 | 首页四类资产卡并展示实时状态 | UI + 数据快照测试 |
| C-03 | 智能支付闭环 | 临期券优先 + 钱包分层扣减 | `smart-checkout` 单测 |
| C-04 | AI/TCA 动态触达 | 活动区可承接服务端注入策略卡 | 快照字段校验 |
| C-05 | 安全与可追溯 | 支付后生成支付单号并保存状态 | `executeCheckout` 测试 |
| C-06 | 隐私与合规 | 顾客端可查本人流水/发票并支持自助注销 | 账户中心 + API 测试 |

---

## 8. 用户角色推演（反推文档与代码）

## 8.1 角色 A：新客首次到店

1. 扫码进入，绑定门店。
2. 首页看到新人礼活动与资产初始值。
3. 发起支付，系统自动抵扣红包与余额。
4. 支付完成后资产下降、支付单号回显。

反推检查：
1. 文档需定义启动绑定、收银算法、支付结果可见性。
2. 代码需提供可执行的 `executeCheckout` 与状态刷新。

## 8.2 角色 B：老客复购

1. 冷启动直接回到最近门店。
2. 首页看到“可兑付口福红包”与余额。
3. 再次支付时优先使用临期红包。

反推检查：
1. 文档需明示“最近门店策略”。
2. 代码需验证“临期券优先”。

## 8.3 角色 C：顾客查账与注销

1. 顾客从首页进入账户中心，查看本人流水与发票列表。
2. 顾客执行二次确认后发起账号注销。
3. 注销成功后会话清理并回到启动页，后续不可继续使用旧账号态。

反推检查：
1. 文档需定义“仅本人可读”的流水/发票查询边界。
2. 代码需实现注销后的会话清理与路由回退。

---

## 9. 当前版本完成度说明

已完成：
1. 启动门店锁定。
2. 动态资产卡渲染。
3. 智能抵扣预览与执行。
4. 顾客端核心测试覆盖。
5. 远程 API 联调开关与自动回退机制。
6. 远程 token 失效自动清理，避免跨门店/跨用户脏凭证残留。
7. 远程 `activities` 动态映射接入，活动区不再依赖固定写死模板。
8. 首页远程快照本地缓存能力已接入，弱网时优先展示最近可用资产快照。
9. 账户中心页面已上线，支持钱包总览/流水列表/发票列表展示。
10. 顾客端已支持自助注销闭环（含二次确认、会话清理与启动页回退）。

后续（不偏离总规范）：
1. 接入真实服务端 API 替换 Mock。
2. 接入真实发票供应商下载链路（当前为平台发票列表能力，供应商接口仍为 mock）。
